#!/bin/bash

export IH_CORE_DIR
IH_CORE_DIR=$(dirname "$(dirname "$(realpath "$0")")")
export IH_CORE_BIN_DIR="$IH_CORE_DIR/bin"
export IH_CORE_LIB_DIR="$IH_CORE_DIR/lib"

# shellcheck source=../lib/confirm.sh
source "$IH_CORE_LIB_DIR/confirm.sh"
# shellcheck source=../lib/colors.sh
source "$IH_CORE_LIB_DIR/colors.sh"
# shellcheck source=../lib/log.sh
source "$IH_CORE_LIB_DIR/log.sh"

# Attempts to return help for the step passed as an argument
function ih::private::step-help() {
  ih::private::try-invoke "$1" help
}

function ih::private::step-test() {
  ih::private::try-invoke "$1" test
  return $?
}

# Attempts to return dependencies for the step passed as an argument
function ih::private::step-deps() {
  ih::private::try-invoke "$1" deps
  return $?
}

function ih::private::step-install() {
  ih::private::try-invoke "$1" install
  return $?
}

# Tries to invoke a step command $2 on a step $1.
# If it can't be invoked because it doesn't exist,
# this will log an error and return 1. Otherwise
# it will return the result of invoking the command.
function ih::private::try-invoke() {
  if [[ $# -ne 2 ]]; then
    ih::log::error "ih::private::try-invoke takes arguments STEP COMMAND"
    return 1
  fi
  local STEP=$1
  local COMMAND=$2
  if command -v "ih::setup::$STEP::$COMMAND" >/dev/null; then
    "ih::setup::$STEP::$COMMAND"
    code=$?
    return $code
  else
    ih::log::error "Step $1 does not implement command $2"
    return 1
  fi
}

function ih::private::list-steps() {
  local STEPS
  local STEP
  local DAG
  local SORTED

  STEPS=$(compgen -A function | grep -E '^ih::setup::[A-z0-9_-]+::install' | grep -v NAME | sed -E 's/ih::setup::(.+)::install/\1/' | sort | tr '\n' ' ')

  for STEP in $STEPS; do
    DEPS=$(ih::private::step-deps "$STEP")
    if [[ -z $DEPS ]]; then
      DAG="$DAG
$STEP $STEP"
    else
      for DEP in $DEPS; do
        DAG="$DAG
$DEP $STEP"
      done
    fi
  done

  SORTED=$(echo "$DAG" | tsort | tr '\n' ' ')

  echo "$SORTED"
}

function ih::private::load-steps() {

  local STEP_FILES
  local STEP_FILE

  STEP_FILES=$(grep -rlE 'function ih::setup::[A-z0-9_-]+::install' "$IH_CORE_LIB_DIR")

  for STEP_FILE in $STEP_FILES; do
    ih::log::debug "Steps found in $STEP_FILE"
    # shellcheck disable=SC1090
    . "$STEP_FILE"
  done
}

# Applies command $1 to the steps listed in the rest of the arguments.
# If there are no steps listed then the command will be applied to
# all the known steps.
function ih::private::apply-to-steps() {
  local COMMAND=$1
  shift
  STEPS=$*
  if [[ -z $STEPS ]]; then
    STEPS=$(ih::private::list-steps)
  fi
  for STEP in $STEPS; do
    "ih::private::$COMMAND" "$STEP"
  done
}

# Prints the description of the step in $1
# along the the deps.
function ih::private::describe-step() {
  blue "--------- $1 -----------\n"
  ih::private::step-help "$1"
  echo ""
  echo "depends on: $(ih::private::step-deps "$1")"
  echo ""
}

# Tests the step $1 with nicer logging.
# If IH_DEBUG is not set to 1 then this will
# discard the output of the test command for the step.
function ih::private::test-step() {
  ih::log::debug "Testing step $STEP..."
  if [[ $IH_DEBUG = "1" ]]; then
    ih::private::step-test "$STEP"
  else
    ih::private::step-test "$STEP" >/dev/null
  fi
  TEST_CODE=$?
  if [[ $TEST_CODE = 0 ]]; then
    green "$STEP has been installed\n"
  else
    red "$STEP needs to be installed\n"
  fi
}

# Tests the dependencies of the step in $1,
# recursively. Returns 1 if any dependency
# is not installed.
function ih::private::test-deps() {
  local DEPTH="$2  "
  local FAILED=0
  local DEP
  local DEPS
  DEPS=$(ih::private::try-invoke "$1" deps)
  for DEP in $DEPS; do
    ih::private::step-test "$DEP" >/dev/null
    TEST_CODE=$?
    if [[ $TEST_CODE != 0 ]]; then
      red "$DEPTH Dependency $DEP not installed\n"
      FAILED=1
    else
      green "$DEPTH Dependency $DEP is installed\n"
    fi
    ih::private::test-deps "$DEP" "$DEPTH"
    TEST_CODE=$?
    if [[ $TEST_CODE != 0 ]]; then
      FAILED=1
    fi
  done

  if [[ $FAILED = "1" ]]; then
    return 1
  fi
  return 0

}

# Calls install on the steps passed as arguments.
# If IH_FORCE is set to 1 it will install each step; otheriwise it will skip steps where
# assert-installed returns 0
# If IH_NO_CONFIRM is set to 1 it will skip confirmation; otherwise it will ask the user to confirm
# before invoking the step.
function ih::private::install-step() {
  local TEST_CODE
  if [ "$IH_FORCE" != "1" ]; then
    ih::log::debug "Checking whether step $STEP needs to be installed..."
    ih::private::step-test "$STEP" >/dev/null
    TEST_CODE=$?
    if [[ $TEST_CODE -eq 0 ]]; then
      ih::log::info "${STEP} has been installed (use --force to re-install)"
      return 0
    fi

    ih::private::test-deps "$STEP" >/dev/null
    TEST_CODE=$?
    if [[ $TEST_CODE -ne 0 ]]; then
      red "$STEP dependencies have not been installed (use --force to ignore)\n"
      ih::private::test-deps "$STEP"
      return 1
    fi

  fi

  ih::log::info "Planning to install step $STEP..."

  if [ "$IH_NO_CONFIRM" != "1" ]; then
    local CONFIRM_TEXT
    CONFIRM_TEXT=$(ih::private::step-help "$STEP")
    if [[ -z $CONFIRM_TEXT ]]; then
      CONFIRM_TEXT="About to install step $STEP"
    fi

    ih::private::confirm "$CONFIRM_TEXT"
    local CONFIRMED_STEP=$?
    if [[ $CONFIRMED_STEP -ne 0 ]]; then
      yellow "Skipping step $STEP\n"
      return 0
    fi
  fi

  ih::private::step-install "$STEP"

  local SUCCCESS=$?
  if [[ $SUCCCESS -eq 0 ]]; then
    green "Installed step $STEP\n"
  else
    ih::log::error "ðŸ’© Installation of step $STEP failed"
    return 1
  fi
}

ih::help() {
  local SUBCOMMANDS
  SUBCOMMANDS=$(ih::private::list-steps | tr '\n' ' ')

  local WITH_HELP=""
  for SUBCOMMAND in $SUBCOMMANDS; do
    SUBCOMMAND=$(printf "    %-18s %s" "$SUBCOMMAND" "$(ih::private::step-help "$SUBCOMMAND" | head -n 1)")
    WITH_HELP="$WITH_HELP
$SUBCOMMAND"
  done

  cat <<USAGE
 Usage:
    ih-setup [flags...] {SUBCOMMAND} [arguments]

 Subcommands:
    help              Show this help

    check [step...]   Check if steps are installed

    describe {step}   Shows details about the step

    install [step...] Install setup steps. If no steps are provided as arguments
                      then all steps not currently installed will be installed,
                      in dependency order.

 Setup Steps:
    ${WITH_HELP}

 Global flags:
    -f    Force command even if heuristics indicate it's not needed
    -y    Don't prompt for confirmation
    -v    Verbose logging

Version:
    $(cat "${IH_CORE_BIN_DIR}/VERSION")

USAGE
}

function main() {

  if [[ $# -eq 0 ]]; then
    ih::help
    exit 0
  fi

  while getopts "yfv" arg; do
    case $arg in
      y) export IH_NO_CONFIRM=1 ;;
      f) export IH_FORCE=1 ;;
      v) export IH_DEBUG=1 ;;
      *)
        ih::help
        exit 1
        ;;
    esac
  done

  shift $((OPTIND - 1))

  local IS_AUGMENT_SOURCED_IN_SHELL
  if [[ $IH_AUGMENT_SOURCED = "yes" ]]; then
    IS_AUGMENT_SOURCED_IN_SHELL="yes"
  fi

  local command=${1:?"Run ih-setup help for usage"}
  shift

  case "${command}" in
    -h | -? | --help) command=help ;;
  esac

  case "${command}" in
    help) ;;

    all)
      ih::private::install-all
      ;;
    install)
      ih::private::apply-to-steps install-step "$*"
      local INSTALL_RESULT
      INSTALL_RESULT=$?
      if [[ -z $IS_AUGMENT_SOURCED_IN_SHELL ]]; then
        ih::log::warn "Remember to source .zshrc or .bashrc to add IH augments to your shell"
      fi
      return $INSTALL_RESULT
      ;;
    describe)
      ih::private::apply-to-steps describe-step "$*"
      return $?
      ;;
    check)
      ih::private::apply-to-steps test-step "$*"
      return $?
      ;;
    private::*)
      : # Assume the caller knows what they're doing
      ;;
    *) ;;

  esac

  ih::${command} "${@}"
}

ih::private::load-steps

main "${@}"
